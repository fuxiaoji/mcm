# 问题1：粉丝投票重构模型 - 调用指南

## 1. 模型概述

**核心类**：`FanVoteReconstructor`

**功能**：基于凸优化约束与 Hit-and-Run 采样，从评委分数和淘汰结果反推粉丝投票分布。

**原理**：
- 将淘汰规则转化为线性不等式约束 $Ax \leq b$
- 单纯形约束 $\sum f_i = 1,\ f_i \geq 0$
- Chebyshev 中心提供可行起点
- Hit-and-Run 在约束多胞体内均匀采样

---

## 2. 快速开始

### 2.1 导入依赖

```python
import numpy as np
import pandas as pd
from scipy.optimize import linprog

# 复制 FanVoteReconstructor 类（见下方完整代码）
```

### 2.2 基本调用

```python
# 输入数据
judge_scores = [29, 28, 30, 30]  # 本周所有选手的评委分数
eliminated_idx = 0               # 被淘汰选手的索引（0-based）
method = 'percentage'            # 'percentage' 或 'rank'

# 创建重构器
reconstructor = FanVoteReconstructor(
    judge_scores=judge_scores,
    eliminated_idx=eliminated_idx,
    method=method
)

# 执行采样
samples = reconstructor.hit_and_run(n_samples=2000, thinning=5)

# 获取结果
if samples is not None:
    mean_votes = samples.mean(axis=0)      # 粉丝票均值估计
    std_votes = samples.std(axis=0)        # 标准差
    ci_low = np.quantile(samples, 0.05, axis=0)   # 5%分位数
    ci_high = np.quantile(samples, 0.95, axis=0)  # 95%分位数
```

---

## 3. 参数说明

### 3.1 构造函数参数

| 参数 | 类型 | 说明 |
|------|------|------|
| `judge_scores` | list/array | 本周所有选手的评委分数 |
| `eliminated_idx` | int | 被淘汰选手的索引（0-based） |
| `method` | str | `'percentage'` 或 `'rank'` |
| `epsilon` | float | 排名法松弛参数（默认1e-6） |

### 3.2 采样参数

| 参数 | 类型 | 说明 | 推荐值 |
|------|------|------|--------|
| `n_samples` | int | 采样数量 | 2000-5000 |
| `thinning` | int | 稀释因子 | 5-10 |

**实际采样次数** = `n_samples × thinning`，返回 `n_samples` 个样本。

### 3.3 方法选择

| 方法 | 适用赛季 | 约束公式 |
|------|----------|----------|
| `'percentage'` | S3-S27 | $\frac{J_{elim}}{\sum J} + f_{elim} \leq \frac{J_i}{\sum J} + f_i$ |
| `'rank'` | S1-S2, S28-S34 | $f_{elim} \leq f_i - \epsilon$ (对评委排名更高者) |

---

## 4. 输出格式

### 4.1 采样结果

```python
samples.shape  # (n_samples, n_contestants)
# 每行是一个粉丝票分布样本，每列是一个选手
# 每行之和 = 1.0
```

### 4.2 统计量计算

```python
# 均值估计
mean_votes = samples.mean(axis=0)

# 置信区间
ci_90 = np.quantile(samples, [0.05, 0.95], axis=0)

# 被淘汰者的估计
elim_vote = mean_votes[eliminated_idx]
elim_std = samples[:, eliminated_idx].std()

# 确定性指数
certainty = 1.0 / (1.0 + elim_std)
```

---

## 5. 完整示例

### 5.1 单案例分析

```python
# Season 5 Week 9 示例
scores = [29, 28, 30, 30]
names = ['Jennie Garth', 'Helio Castroneves', 'Cameron Mathison', 'Marie Osmond']
eliminated = 0  # Jennie Garth

reconstructor = FanVoteReconstructor(scores, eliminated, method='percentage')
samples = reconstructor.hit_and_run(n_samples=2000, thinning=5)

if samples is not None:
    mean_votes = samples.mean(axis=0)
    
    # 打印结果
    for i, (name, vote) in enumerate(zip(names, mean_votes)):
        marker = '← ELIMINATED' if i == eliminated else ''
        print(f"{name}: {vote:.2%} {marker}")
```

### 5.2 从数据集提取案例

```python
def extract_week_case(df, season, week):
    """从数据集提取指定赛季和周次的案例"""
    season_df = df[df['season'] == season]
    week_col = f'week{week}_avg_score'
    
    participants = season_df[season_df[week_col].notna()].copy()
    elim_mask = participants['weeks_survived'] == week
    
    if elim_mask.sum() != 1:
        raise ValueError('无法确定唯一淘汰者')
    
    eliminated_name = participants.loc[elim_mask, 'celebrity_name'].iloc[0]
    participants = participants.reset_index(drop=True)
    eliminated_idx = participants[participants['celebrity_name'] == eliminated_name].index[0]
    
    scores = participants[week_col].tolist()
    names = participants['celebrity_name'].tolist()
    
    return scores, names, eliminated_idx

# 使用示例
df = pd.read_csv('MCM_Problem_C_Processed.csv')
scores, names, elim_idx = extract_week_case(df, season=5, week=3)

# 确定方法
method = 'rank' if season in [1, 2] or season >= 28 else 'percentage'

# 重构
reconstructor = FanVoteReconstructor(scores, elim_idx, method=method)
samples = reconstructor.hit_and_run(n_samples=2000, thinning=5)
```

### 5.3 批量分析

```python
def batch_reconstruct(cases):
    """批量重构多个案例"""
    results = []
    
    for case in cases:
        season = case['season']
        method = 'rank' if season in [1, 2] or season >= 28 else 'percentage'
        
        reconstructor = FanVoteReconstructor(
            case['scores'], 
            case['eliminated_idx'], 
            method=method
        )
        samples = reconstructor.hit_and_run(n_samples=2000, thinning=5)
        
        if samples is not None:
            mean_votes = samples.mean(axis=0)
            results.append({
                'season': season,
                'week': case['week'],
                'eliminated_fan_vote': mean_votes[case['eliminated_idx']],
                'certainty': 1.0 / (1.0 + samples[:, case['eliminated_idx']].std())
            })
    
    return pd.DataFrame(results)
```

---

## 6. 完整类代码

```python
class FanVoteReconstructor:
    def __init__(self, judge_scores, eliminated_idx, method='percentage', epsilon=1e-6):
        self.scores = np.array(judge_scores, dtype=float)
        self.n = len(judge_scores)
        self.eliminated = int(eliminated_idx)
        self.method = method
        self.epsilon = float(epsilon)
        self.A_eq = np.ones((1, self.n))
        self.b_eq = np.array([1.0])

    def _build_constraints(self):
        A_ub, b_ub = [], []
        
        # 非负约束
        for i in range(self.n):
            row = np.zeros(self.n)
            row[i] = -1
            A_ub.append(row)
            b_ub.append(0.0)

        # 淘汰规则约束
        if self.method == 'percentage':
            J_total = np.sum(self.scores)
            J_perc = self.scores / J_total
            for i in range(self.n):
                if i == self.eliminated:
                    continue
                row = np.zeros(self.n)
                row[self.eliminated] = 1
                row[i] = -1
                A_ub.append(row)
                b_ub.append(float(J_perc[i] - J_perc[self.eliminated]))
                
        elif self.method == 'rank':
            ranks_j = np.argsort(np.argsort(-self.scores)) + 1
            for i in range(self.n):
                if i == self.eliminated:
                    continue
                if ranks_j[self.eliminated] >= ranks_j[i]:
                    row = np.zeros(self.n)
                    row[self.eliminated] = 1
                    row[i] = -1
                    A_ub.append(row)
                    b_ub.append(-self.epsilon)
                    
        return np.array(A_ub), np.array(b_ub).ravel()

    def find_chebyshev_center(self, A_ub, b_ub):
        n_vars = self.n
        c = np.zeros(n_vars + 1)
        c[-1] = -1
        
        A_lp = []
        for i in range(len(b_ub)):
            row = np.zeros(n_vars + 1)
            row[:n_vars] = A_ub[i]
            row[-1] = np.linalg.norm(A_ub[i])
            A_lp.append(row)
        A_lp = np.array(A_lp)
        
        A_eq_lp = np.zeros((1, n_vars + 1))
        A_eq_lp[0, :n_vars] = 1
        
        res = linprog(c, A_ub=A_lp, b_ub=b_ub, A_eq=A_eq_lp, 
                      b_eq=self.b_eq, bounds=(0, None), method='highs')
        
        if res.success:
            return res.x[:n_vars]
        raise ValueError('无法找到可行起点')

    def hit_and_run(self, n_samples=5000, thinning=10):
        A_ub, b_ub = self._build_constraints()
        
        try:
            x0 = self.find_chebyshev_center(A_ub, b_ub)
        except ValueError:
            return None
        
        samples, current_x = [], x0
        
        for _ in range(n_samples * thinning):
            d = np.random.normal(size=self.n)
            d = d - np.mean(d)
            d = d / np.linalg.norm(d)
            
            Ad = A_ub @ d
            b_Ax = b_ub - A_ub @ current_x
            
            lambda_min, lambda_max = -np.inf, np.inf
            for i in range(len(b_ub)):
                if abs(Ad[i]) < 1e-10:
                    continue
                val = b_Ax[i] / Ad[i]
                if Ad[i] > 0:
                    lambda_max = min(lambda_max, val)
                else:
                    lambda_min = max(lambda_min, val)
            
            if lambda_max > lambda_min:
                step = np.random.uniform(lambda_min, lambda_max)
                current_x = current_x + step * d
                current_x = np.clip(current_x, 0, None)
                current_x = current_x / current_x.sum()
            
            samples.append(current_x.copy())
        
        return np.array(samples[::thinning])
```

---

## 7. 常见问题

### Q1: 返回 None 怎么办？

约束不可行，可能原因：
- 评委分数输入错误
- 淘汰者索引错误
- 数据存在异常

### Q2: 如何提高采样质量？

- 增加 `n_samples`（如 5000）
- 增加 `thinning`（如 10）
- 检查置信区间宽度

### Q3: 如何判断结果可靠性？

- **确定性指数**：`certainty = 1/(1+std)`，越高越可靠
- **置信区间宽度**：越窄越确定
- **样本方差**：越小越稳定

---

## 8. 规则速查表

| 赛季 | 方法 | 说明 |
|------|------|------|
| S1-S2 | `'rank'` | 早期赛季使用排名法 |
| S3-S27 | `'percentage'` | 中期赛季使用百分比法 |
| S28-S34 | `'rank'` | 近期赛季恢复排名法 |

```python
def get_method(season):
    if season in [1, 2] or season >= 28:
        return 'rank'
    else:
        return 'percentage'
```
