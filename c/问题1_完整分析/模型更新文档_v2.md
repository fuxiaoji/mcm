# 粉丝投票反演模型 - 更新文档 v2.0

## 更新日期
2026-01-30

## 更新概述

本次更新大幅提升了问题1粉丝投票反演模型的覆盖范围，从原来的54%（228/421）提升至96.8%（395/408）。主要新增了两个关键功能：

1. **决赛选手支持**：为从未被淘汰的冠军、亚军、季军等提供粉丝票估计
2. **双淘汰/多人淘汰支持**：处理同一周多人被淘汰的情况

---

## 主要变更

### 1. 新增决赛选手重构功能

#### 问题背景
原模型只能处理淘汰事件——利用"被淘汰者总分（评委分+粉丝票）最低"这一约束来反推粉丝票。但决赛选手（冠军、亚军、季军等）从未被淘汰，因此原模型无法为他们估计粉丝票。

这导致了一个严重的数据缺口：**34季所有冠军都没有粉丝票估计**，这对问题4的"什么因素决定冠军"分析造成了困难。

#### 解决方案
新增 `FinalistVoteReconstructor` 类，利用决赛名次作为约束：

```
冠军粉丝票 > 亚军粉丝票 > 季军粉丝票 > ...
```

数学表示：
$$f_{1st} > f_{2nd} > f_{3rd} > \ldots$$

#### 实现细节
- 约束矩阵：`A_rank * f <= -ε`，其中 ε = 0.001 是最小间隔
- 采样方法：与原模型相同的 Hit-and-Run MCMC
- 识别决赛选手：`results == 'Winner'` 且 `placement <= 5`

#### 新增记录
- 34 季冠军（100%覆盖）
- 34 季亚军
- 34 季季军
- 9 个第四/第五名
- **共计 111 条决赛选手记录**

---

### 2. 新增双淘汰/多人淘汰支持

#### 问题背景
原模型只处理 `n_eliminated == 1` 的情况。但实际比赛中存在大量双淘汰（同一周淘汰2人或更多）的情况。

#### 解决方案
修改 `get_all_elimination_cases()` 函数，新增 `include_multi_elim=True` 参数：
- 当同一周有多人被淘汰时，为每个被淘汰者单独生成一条记录
- 每条记录使用该周开始时的参赛者名单
- 约束条件：该被淘汰者的总分 ≤ 所有其他选手

#### 新增记录
- **96 条双/多人淘汰记录**

---

## 数据变化

### 覆盖率对比

| 指标 | 更新前 | 更新后 | 变化 |
|------|--------|--------|------|
| 总记录数 | 228 | 435 | +207 (+90.8%) |
| 淘汰事件 | 228 | 324 | +96 (+42.1%) |
| 决赛选手 | 0 | 111 | +111 (新增) |
| 选手覆盖率 | 228/421 (54%) | 395/408 (96.8%) | +42.8% |
| 冠军覆盖率 | 0/34 (0%) | 34/34 (100%) | +100% |

### 未覆盖情况
仍有 13 位选手（3.2%）无法估计粉丝票：
- **10 位退赛选手**（Withdrew）：未参与正常淘汰流程
- **3 位边缘情况**：如 Joey McIntyre (S1 W11) 因规则特殊无法建模

---

## 文件变更

### 新增文件

| 文件名 | 说明 |
|-------|------|
| `问题1_选手汇总表.csv` | 408位选手的汇总信息（供问题4使用） |
| `问题1_综合分析图表_v2.png` | 更新后的4面板分析图 |
| `模型更新文档_v2.md` | 本文档 |

### 修改文件

| 文件名 | 变更内容 |
|-------|---------|
| `问题1.ipynb` | 新增决赛重构类和双淘汰支持 |
| `问题1_批量结果_完整.csv` | 从 228 行扩展至 435 行 |
| `问题1_最终报告.md` | 更新统计数据和方法描述 |

### 数据文件结构更新

`问题1_批量结果_完整.csv` 新增列：
- `is_finalist`：是否为决赛选手 (bool)
- `placement`：最终名次 (int)
- `size_group`：参赛规模分组 ('small'/'medium'/'large')

`问题1_选手汇总表.csv` 列说明：
```
celebrity_name          # 选手姓名
season                  # 赛季
ballroom_partner        # 舞伴
celebrity_industry      # 行业
celebrity_age           # 年龄
is_international        # 是否国际选手
weeks_survived          # 存活周数
season_avg_score        # 赛季平均分
season_score_std        # 赛季分数标准差
season_max_score        # 赛季最高分
season_min_score        # 赛季最低分
final_result            # 最终结果
placement               # 最终名次
fan_vote_estimate       # 粉丝票估计值
fan_vote_std            # 粉丝票标准差
fan_vote_ci_low         # 95%置信区间下限
fan_vote_ci_high        # 95%置信区间上限
fan_certainty           # 确定性指数
is_finalist             # 是否决赛选手
avg_fan_vote            # 平均粉丝票（多条记录时）
fan_vote_records        # 粉丝票记录数
is_Actor_Actress        # 行业哑变量...
is_Athlete
is_TV_Personality
...
```

---

## 确定性分析更新

### 整体统计

| 统计量 | 更新前 | 更新后 |
|-------|--------|--------|
| 平均确定性 | 0.981 | 0.960 |
| 中位数 | 0.985 | 0.977 |
| 最小值 | 0.945 | 0.830 |
| 最大值 | 0.995 | 0.999 |

### 分类统计

| 类型 | 记录数 | 平均确定性 |
|-----|-------|-----------|
| 单人淘汰 | 228 | 0.981 |
| 双人淘汰 | 96 | ~0.96 |
| 决赛选手 | 111 | 0.918 |

**说明**：决赛选手的确定性较低（平均 0.918），原因是约束条件较少（仅有名次约束，无淘汰约束）。这是预期行为，不影响估计的有效性。

---

## 对下游分析的影响

### 问题2（方法对比）
- 数据源自动更新
- 分析结论基本不变
- 如需更新，重新运行 notebook 即可

### 问题4（冠军预测/特征分析）
- **重大利好**：现在有34季所有冠军的粉丝票估计
- 可以使用 `问题1_选手汇总表.csv` 进行特征工程
- 建议使用 XGBoost + SHAP 进行分析（待实施）

---

## 技术实现总结

### 核心类

```python
class FanVoteReconstructor:
    """原淘汰事件重构器"""
    # 约束：被淘汰者总分 ≤ 其他所有人
    # J_e + f_e <= J_j + f_j, for all j != e

class FinalistVoteReconstructor:
    """新增：决赛选手重构器"""
    # 约束：名次越高，粉丝票越高
    # f_1st > f_2nd > f_3rd > ...
```

### 关键函数

```python
def get_all_elimination_cases(frame, include_multi_elim=True):
    """提取所有淘汰案例，支持多人淘汰"""

def get_finalist_cases(frame):
    """提取所有决赛选手"""

def batch_reconstruct_finalists(finalist_cases, frame, n_samples=5000):
    """批量重构决赛选手粉丝票"""
```

---

## 验证

### 覆盖率验证
```python
unique_names = set(full_results_df['eliminated_name'].unique())
all_names = set(df_main['celebrity_name'].unique())
coverage = len(unique_names) / len(all_names)  # 96.8%
```

### 冠军验证
```python
champions = df_main[df_main['results'] == 'Winner']['celebrity_name']
covered = champions.isin(full_results_df['eliminated_name'])
coverage = covered.mean()  # 100%
```

---

## 后续计划

1. [ ] 问题4：使用新数据构建 XGBoost + SHAP 模型
2. [ ] 问题2：验证新数据对方法对比结论的影响
3. [ ] 考虑为退赛选手建立单独的估计模型

---

**文档作者**：MCM Problem C 分析团队  
**版本**：v2.0  
**更新日期**：2026-01-30
